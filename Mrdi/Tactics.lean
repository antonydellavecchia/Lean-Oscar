import Mathlib
import Mrdi.Basic
import Mrdi.Stream
import Mrdi.ToExpr
import Mrdi.Server
import Mrdi.ToMrdiNoncomputable
import Mrdi.ListToSet
import Std
import Qq
import Mathlib.Tactic.ToExpr

namespace Mrdi.Tactic

open Qq Lean Elab Tactic Meta IO.MrdiFile Expr Server

/-- `load_file file` loads from mrdi-files/file.mrdi -/
syntax "load_file " term : tactic
elab_rules : tactic
  | `(tactic| load_file $file) => do
    let fileE ← elabTerm file q(String)
    let goal ← getMainGoal
    goal.withContext do
      let α ← goal.getType
      let a ← IO.MrdiFile.loadMrdiFromFile α fileE (trace := False)
      goal.assign a


section Matrix_inverse

/-- Takes a matrix, returns the type of the elements and the dimensions -/
private def matrixType (u) (x : Q(Type $u)) : MetaM (Q(Type u) × Q(ℕ) × Q(ℕ)) := match x with
  | ~q(((Matrix (Fin ($m + 1)) (Fin ($n + 1)))) $α) => return (q($α), q($m) ,q($n))
  | _ => throwError "input didn't match expected type"

def matrix_inverse' (A : Expr) (goal : MVarId) : TacticM Unit := do
  let tA ← inferType A
  let .sort u ← instantiateMVars (← whnf (← inferType tA)) | unreachable!
  let some v := u.dec | throwError "not a type{indentExpr tA}"
  let (α, m, n) ← matrixType ql(v) tA
  let A_mrdi : Mrdi ← Mrdi? A
  let inv_mrdi ← julia "matrix inverse" A_mrdi
  let inv : Q(Matrix (Fin ($m + 1)) (Fin ($n + 1)) $α) ← evalMrdi q(Matrix (Fin ($m + 1)) (Fin ($n + 1)) $α) inv_mrdi
  goal.assign inv
  return

def matrix_inverse (A : Expr) (goal : MVarId) : TacticM Unit := do
  let tA ← inferType A
  let .sort u ← instantiateMVars (← whnf (← inferType tA)) | unreachable!
  let some v := u.dec | throwError "not a type{indentExpr tA}"
  let (α, m, n) ← matrixType ql(v) tA
  let inv ← julia' "matrix inverse" A q(Matrix (Fin ($m + 1)) (Fin ($n + 1)) $α)
  goal.assign inv
  return

syntax "matrix_inverse " term : tactic
elab_rules : tactic
  | `(tactic| matrix_inverse $A) => do
    let A ← elabTerm A none
    let goal ← getMainGoal
    matrix_inverse A goal

end Matrix_inverse


section Permutation

/-- A product of elements of a vector is in the Group generated by the elements of the vector.
    And so is the product defined by the lifting the word. -/
theorem FreeGroup_lift_word_mem_GroupClosure [Group α] {n : ℕ} (v : Vector α n) (word : FreeGroup (Fin n)) :
  let f : FreeGroup (Fin n) →* α := (FreeGroup.lift fun (i : Fin n) => Vector.get v i)
  f word ∈ Group.closure (List.toSet v.toList) := by
    have h (x : Fin n) : (FreeGroup.lift fun i => Vector.get v i) (pure x) = v.get x := FreeGroup.lift.of
    induction word using FreeGroup.induction_on with
      | C1 => apply Group.InClosure.one
      | Cp x =>
          apply Group.InClosure.basic
          simp [List.toSet_mem, h]
      | Ci x _ =>
          simp [h]
          apply Group.InClosure.inv
          apply Group.InClosure.basic
          simp [List.toSet_mem]
      | Cm x y hx hy =>
          simp [h] at *
          apply Group.InClosure.mul hx hy

-- TODO how can I use `Lean.Meta.replaceTargetEq` and get `eqProof` as a new goal without writing a new definition for it?
/--
  Convert the given goal `Ctx |- target` into `Ctx |- targetNew` and an equality proof `eqProof : target = targetNew`.
-/
def replaceTargetEq (mvarId : MVarId) (targetNew : Expr) : MetaM (MVarId × MVarId) :=
  mvarId.withContext do
    mvarId.checkNotAssigned `replaceTarget
    let target   ← mvarId.getType
    let eq       ← mkEq target targetNew
    let mvarEq   ← mkFreshExprSyntheticOpaqueMVar eq `eqProof
    let tag      ← mvarId.getTag
    let mvarNew  ← mkFreshExprSyntheticOpaqueMVar targetNew tag
    let u        ← getLevel target
    let val  := mkAppN (Lean.mkConst `Eq.mpr [u]) #[target, targetNew, mvarEq, mvarNew]
    mvarId.assign val
    return (mvarNew.mvarId!, mvarEq.mvarId!)

def PermsToList (u) (α : Q(Type $u)) (g : Q($α)) (gens : Q(Set $α)) : MetaM $ Q(List $α) × Q(List $α) := do
  let gens : Q(List $α) ← Set.toList gens
  return (q($g :: $gens), q($gens))

/- Solves goals of type `x ∈ Group.closure {a, b, c, ...}` where `x`, `a`, `b`, `c`, ... are permutations -/
def perm_group_membership (goal : MVarId) : TacticM Unit := do
  let goal_type ← goal.getType
  let some (g_type, γ, mem_inst, g, closure_set) := app5? goal_type ``Membership.mem | throwError "not a goal of type g ∈ G"
  let .sort sort_v ← inferType γ | throwError "not a sort"
  let some v := sort_v.dec | throwError "not a type{indentExpr (.sort sort_v)}"
  have γ : Q(Type $v) := γ
  have closure_set : Q($γ) := closure_set
  let .sort sort_u ← inferType g_type | throwError "not a sort"
  let some u := sort_u.dec | throwError "not a type{indentExpr (.sort sort_u)}"
  have g_type : Q(Type $u) := g_type
  have g : Q($g_type) := g
  let some (_, inst, gens) :=  closure_set.app3? ``Group.closure | throwError "G is not a Group.closure"
  have _ : Q(Group $g_type) := inst
  let (g_and_gens, gens) ← PermsToList u g_type g gens
  let n : Q(ℕ) := q(List.length $gens)
  let gens_vector : Q(Vector $g_type $n) := q(⟨$gens, rfl⟩)
  let n' ← unsafe evalExpr ℕ q(ℕ) n
  have n : Q(ℕ) := toExpr n'
  let mrdi : Mrdi ← IO.MrdiFile.Mrdi? g_and_gens
  let word_mrdi : Mrdi ← julia "perm group membership" mrdi
  let word : Q(FreeGroup (Fin $n)) ← evalMrdi q(FreeGroup (Fin $n)) word_mrdi
  let word : Q(Expr) := q(toExpr $word)
  let word ← unsafe evalExpr Expr q(Expr) word
  have word : Q(FreeGroup (Fin (List.length $gens))) := word
  let _ ← synthInstanceQ q(Inhabited $g_type)
  let prod := q(FreeGroup.lift (fun (x : Fin (List.length $gens)) => Vector.get $gens_vector x) $word)
  have _ : Q(Membership $g_type $γ) := mem_inst
  let targetNew := q($prod ∈ $closure_set)
  let (new_goal, eq_goal) ← replaceTargetEq goal targetNew
  let eq_goal ← eq_goal.withContext do
    let tacticCode ← `(tactic| congr; ext x; fin_cases x; any_goals rfl)
    let (eq_goal, _) ← Elab.runTactic eq_goal tacticCode
    return eq_goal
  let new_goal ← new_goal.withContext do
    let tacticCode ← `(tactic| apply FreeGroup_lift_word_mem_GroupClosure)
    let (new_goal, _) ← Elab.runTactic new_goal tacticCode
    return new_goal
  replaceMainGoal (new_goal ++ eq_goal)

/- Solves goals of type `x ∈ Group.closure {a, b, c, ...}` where `x`, `a`, `b`, `c`, ... are permutations -/
syntax "perm_group_membership " : tactic
elab_rules : tactic
  | `(tactic| perm_group_membership) => do
    let goal ← getMainGoal
    perm_group_membership goal

end Permutation

section KBMAG

private def fp_group_n {u} {α : Q(Type $u)} (rels : Q(List (FreeGroup $α))) :
  MetaM Q(ℕ) := do
    match q($α) with
    | ~q(Fin $n) => return q($n)
    | _ => throwError "not a Fin n"

private def fingroupType
  (u) (G : Q(Sort $u)) :
  MetaM Q(ℕ) := match q($G) with
    | ~q(PresentedGroup (List.toSet $rels)) => do
        let n ← fp_group_n q($rels)
        return n
    | _ => throwError "input didn't match expected type"

private def fpgroupRels (n : Q(ℕ))
  (u) (G : Q(Sort $u)) :
  MetaM Q(List (FreeGroup (Fin $n))) := match q($G) with
    | ~q(PresentedGroup (List.toSet $rels)) => do
        have rels : Q(List (FreeGroup (Fin $n))) := rels
        return rels
    | _ => throwError "input didn't match expected type"

private def fp_group_group (n : Q(ℕ)) (rels : Q(List (FreeGroup (Fin $n))))
  (G : Q(PresentedGroup (List.toSet $rels))) :
  MetaM Q(PresentedGroup (List.toSet $rels)) := do
    return q($G)

-- TODO what should be reduced first?
def kbmag (g : Expr) (goal : MVarId) : TacticM Unit := do
  goal.withContext do
    let ⟨u, G, g⟩ ← inferTypeQ g

    let n ← fingroupType u G
    let n' : ℕ ← unsafe evalExpr ℕ q(ℕ) n
    let rels ← fpgroupRels n u G
    let G ← fp_group_group n rels G
    let G_stx := ← Term.exprToSyntax G
    let g_mrdi : Mrdi ← IO.MrdiFile.Mrdi? g

    let val_ident (i : ℕ) := mkIdent (.str .anonymous s!"_g{2 * i + 1}")
    let val_def_ident (i : ℕ) := mkIdent (.str .anonymous s!"_g{2 * i + 1}_def")
    let inv_ident (i : ℕ) := mkIdent (.str .anonymous s!"_g{2 * i + 2}")
    let def_inv_ident (i : ℕ) := mkIdent (.str .anonymous s!"_g{2 * i + 2}_def")
    let val_inv_ident (i : ℕ) := mkIdent (.str .anonymous s!"h{2 * i + 1}")
    let inv_val_ident (i : ℕ) := mkIdent (.str .anonymous s!"h{2 * i + 2}")

    for i in List.range n' do
      evalTactic (← `(tactic|
        set $(val_ident i) : $G_stx := PresentedGroup.of $(quote i) with $(val_def_ident i);
        set $(inv_ident i) : $G_stx := (PresentedGroup.of $(quote i))⁻¹ with $(def_inv_ident i);
        (have $(val_inv_ident i) : $(val_ident i) * $(inv_ident i) = 1 := by apply mul_inv_self);
        have $(inv_val_ident i) : $(inv_ident i) * $(val_ident i) = 1 := by apply inv_mul_self
      ))

    -- let s := "_g1 = _g2"
    -- let ident := mkIdent (.str .anonymous s)
    -- evalTactic (← `(tactic| have $(val_inv_ident 100) : $ident := by sorry))

    let mrdi : Mrdi ← julia "kbmag" g_mrdi
    -- -- equation number, initial/overlap, two overlap numbers, equation0
    -- let steps ← evalMrdi' (List (ℕ × Bool × ℕ × ℕ × String)) mrdi
    -- for step in steps do
    --   let ⟨equation_number, new_equation, overlap₁, overlap₂, equation⟩ := step
    return


#check Lean.Elab.runTactic
#check Syntax.mkCApp

syntax "kbmag " term : tactic
elab_rules : tactic
  | `(tactic| kbmag $g) => do
    let g ← elabTerm g none
    let goal ← getMainGoal
    kbmag g goal

@[reducible]
def f := FreeGroup (Fin 2)

def a : f := FreeGroup.mk [(1, true)]
def b : f := FreeGroup.mk [(2, true)]

def rels_list := [a * b * a⁻¹ * b⁻¹ * a⁻¹, b * a * b⁻¹ * a⁻¹ * b⁻¹]
@[reducible]
def rels := List.toSet rels_list

@[reducible]
def g := PresentedGroup rels

def test : List f := by
  kbmag (1 : g)
  sorry

end KBMAG

end Mrdi.Tactic
