import Mrdi
import Mathlib
import Std

/- Only notes. Nothing serious implemented yet. -/

open Mrdi Lean Lean.Elab Command Term Lean.Elab.Tactic Tactic

open Group

/-
- Coset enumeration
In an ideal situation, you could have Lean automatically prove that F(2,9) is infinite,
see https://arxiv.org/pdf/math/9507204.pdf but this is probably too ambitious.
See also https://docs.gap-system.org/doc/ref/chap47.html, section 47.16.
Furthermore, having something of the kind -/

@[reducible]
def G := FreeGroup (Fin 2)

def a : G := FreeGroup.mk [(0, true)]
def b : G := FreeGroup.mk [(1, true)]
def l := [a⁻¹*b*a*(b⁻¹)^2, b⁻¹*a*b*(a⁻¹)^2]
def s := List.toSet l

def triv := PresentedGroup s

instance : Fintype triv := sorry

theorem test3 : Fintype.card triv = 1 := by
  --coset_enumeration
  sorry

--noncomputable
instance [ToMrdi α] : ToMrdi $ Multiset α where
  toMrdi uuids s := sorry --toMrdi uuids (Multiset.toList s)

instance [ToMrdi α] : ToMrdi $ Finset α where
  toMrdi uuids s := toMrdi uuids s.val

instance [ToMrdi α] [Fintype α] : ToMrdi α where
  toMrdi uuids _ := toMrdi uuids (Fintype.elems (α := α))

instance [ToMrdi α] [Fintype α] : ToMrdi $ Set α where
  toMrdi uuids s := toMrdi uuids (Fintype.elems (α := α))

instance {rels : Finset (FreeGroup α)} [ToMrdi α] : ToMrdi $ PresentedGroup (rels : Set (FreeGroup α)) where
  toMrdi g := sorry

/-
for coset tables
1. define coset table
4. theorem coset.card = coset.table.card
3. theorem : coset.card * order of subgroup = order of group
-/

--TODO that's not correct. think again
/- coset table = a List of elements + a proof that the List generates G + a proof that the List is mul closed
                 + a proof that all elements are different -/

/- proof that the List generates G is trivial cause it contains the generators -/


/- order of cyclic subgroup by showing a^n = 1 and a^k ≠ 1 for k < n? -/


open scoped Pointwise

def left_coset := a • s
def right_coset := MulOpposite.op a • s

def quot := QuotientGroup.Quotient.group (Subgroup.normalClosure s)

def quot_for_cyclic_subgroup := QuotientGroup.Quotient.group (Subgroup.normalClosure {a})

def quot_for_cyclic_subgroup' := G ⧸ (Subgroup.normalClosure {a})

#check Subgroup.groupEquivQuotientProdSubgroup

/-
is perhaps within reach? For this, you'll have to understand how GAP does it.
The most performant algorithm selects a generator, and tries to compute a coset table
for the cyclic subgroup generated by this element. If this works, the order will be
(size of coset table) * (order of subgroup, which can be read from the cyclic subgroup's presentation).

-/
